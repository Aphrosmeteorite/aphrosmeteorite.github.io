<!doctype html><html lang=zh-CN data-theme=dark><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.127.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="C++类模版"><meta itemprop=description content="A brief note about C++ class template"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="http://localhost:1313/imgs/kana.png"><meta itemprop=keywords content="C++"><meta property="og:type" content="article"><meta property="og:title" content="C++类模版"><meta property="og:description" content="A brief note about C++ class template"><meta property="og:image" content="/imgs/kana.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="http://localhost:1313/post/cpp-class-template/"><meta property="og:site_name" content="lap的小站"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Laplace"><meta property="article:published_time" content="2024-06-14 00:00:00 +0000 UTC"><meta property="article:modified_time" content="2024-06-14 00:00:00 +0000 UTC"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"math":{"js":{"file":"es5/tex-mml-chtml.js","name":"mathjax","version":"3.2.0"},"render":"mathjax"},"path":"cpp-class-template","permalink":"http://localhost:1313/post/cpp-class-template/","title":"C++类模版","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.id="LA_COLLECT",e.src="https://sdk.51.la/js-sdk-pro.min.js",e.async="true",e.onload=function(){LA.init({id:"3HTyuds4Bm5FaDq4",ck:"3HTyuds4Bm5FaDq4",autoTrack:!0})},document.head.appendChild(e)})</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>C++类模版 - lap的小站</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>lap的小站</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>When the SUN Rises in the EAST</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-flinks"><a href=/flinks.html class=hvr-icon-pulse rel=section><i class="fa fa-thumbs-up hvr-icon"></i>友情链接</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>22</span></a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#定义一个类模板>定义一个类模板</a></li><li><a href=#省略显式指出模板类型since-c17>省略显式指出模板类型(since C++17)</a></li><li><a href=#推断指引>推断指引</a></li><li><a href=#模板部分特例化>模板部分特例化</a></li><li><a href=#聚合类的模版>聚合类的模版</a></li><li><a href=#为模版类进行函数重载>为模版类进行函数重载</a></li><li><a href=#总结>总结</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Laplace src=/imgs/img-lazy-loading.gif data-src=/imgs/kana.png><p class=site-author-name itemprop=name>Laplace</p><div class=site-description itemprop=description>当太阳从东方升起</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>22</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>8</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>6</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/Laplace825 title="Github → https://github.com/Laplace825" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=laplace_yongle_he@163.com title="E-Mail → laplace_yongle_he@163.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>
E-Mail</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href title target=_blank>暂无 QAQ</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item></div><div id=la-siteinfo-widget style=display:none></div><div class=siteinfo-item><div class=item-name><i class="fa fa-user-plus"></i>今日访问：</div><div class=item-count id=today_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-user-clock"></i>昨日访问：</div><div class=item-count id=yesterday_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-arrows-down-to-people"></i>本月访问：</div><div class=item-count id=month_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-users"></i>总访问量：</div><div class=item-count id=total_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=27683></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=66></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2024-06-01T00:00:00+00:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-gtranslate class=button title=多语言翻译><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/laplace825 rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub ฅ( ̳• ◡ • ̳)ฅ" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=http://localhost:1313/post/cpp-class-template/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/kana.png"><meta itemprop=name content="Laplace"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Laplace"><meta itemprop=description content="当太阳从东方升起"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="C++类模版"><meta itemprop=description content="A brief note about C++ class template"></span><header class=post-header><h1 class=post-title itemprop="name headline">C++类模版</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-06-14 00:00:00 +0000 UTC" itemprop="dateCreated datePublished" datetime="2024-06-14 00:00:00 +0000 UTC">2024-06-14
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/c++-template-meta-programming itemprop=url rel=index><span itemprop=name>C++/C++ template meta programming</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>2814</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>6分钟</span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><p>继续开新坑了♿，<code>C++</code> 模版元编程。作为一个记录笔记吧。如有错误，也请原谅QAQ，代码都是用<code>msvc clang</code>编译跑通。</p><h2 id=定义一个类模板>定义一个类模板
<a class=header-anchor href=#%e5%ae%9a%e4%b9%89%e4%b8%80%e4%b8%aa%e7%b1%bb%e6%a8%a1%e6%9d%bf></a></h2><p>相信大家已经会使用<code>C++</code>定义类模板了，不就是在定义的时候多加一行<code>template&lt;typename T></code> 吗。是的，这是最基础的泛型。例如下面的一个<code>Stack</code>类，就是一个模板类。在接下来的讲解中，请你不要关注<code>Stack</code>这个类本身的作用(例如栈)，这里我们仅仅以此为例，并讨论各种可能与模板类相关的语法，请忽略这种想法“这样定义一个构造函数没意义啊”，我们只讨论语法上的规则和可能性。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#c678dd>template</span> <span style=color:#56b6c2>&lt;</span><span style=color:#c678dd>typename</span> <span style=color:#e06c75>T</span><span style=color:#56b6c2>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>Stack</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#c678dd>private</span><span style=color:#56b6c2>:</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>vector</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>T</span><span style=color:#56b6c2>&gt;</span> <span style=color:#e06c75>m_data</span>;
</span></span><span style=display:flex><span><span style=color:#c678dd>public</span><span style=color:#56b6c2>:</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>Stack</span>() <span style=color:#56b6c2>=</span> <span style=color:#c678dd>default</span>;
</span></span><span style=display:flex><span>    <span style=color:#e06c75>Stack</span>(<span style=color:#e06c75>Stack</span> <span style=color:#c678dd>const</span><span style=color:#56b6c2>&amp;</span>); <span style=color:#7f848e>// 参数不指定模板特化类型,默认与当前被构造的Stack类型一致
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>    <span style=color:#e06c75>Stack</span>(<span style=color:#e06c75>Stack</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>T</span><span style=color:#56b6c2>&gt;</span> <span style=color:#56b6c2>&amp;</span>, <span style=color:#e06c75>size_t</span> <span style=color:#e06c75>size</span>);
</span></span><span style=display:flex><span>    <span style=color:#e06c75>Stack</span>(<span style=color:#e06c75>T</span> <span style=color:#e06c75>elem</span>) <span style=color:#56b6c2>:</span> <span style=color:#e06c75>m_data</span>({<span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>move</span>(<span style=color:#e06c75>elem</span>)}) {}
</span></span><span style=display:flex><span>    <span style=color:#e06c75>Stack</span>(<span style=color:#c678dd>const</span> <span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>initializer_list</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>T</span><span style=color:#56b6c2>&gt;</span> <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>initList</span>) <span style=color:#56b6c2>:</span> <span style=color:#e06c75>m_data</span>(<span style=color:#e06c75>initList</span>) {}
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=省略显式指出模板类型since-c17>省略显式指出模板类型(since C++17)
<a class=header-anchor href=#%e7%9c%81%e7%95%a5%e6%98%be%e5%bc%8f%e6%8c%87%e5%87%ba%e6%a8%a1%e6%9d%bf%e7%b1%bb%e5%9e%8bsince-c17></a></h2><p>从<code>C++17</code>开始，我们可以不用再显式指出一个模版类的模版参数类型(默认值除外)，例如下面这段代码在<code>C++17</code>以后可以成功编译。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#e06c75>Stack</span> <span style=color:#e06c75>stk_initList</span>{<span style=color:#98c379>&#34;Hello&#34;</span>};
</span></span><span style=display:flex><span><span style=color:#e06c75>Stack</span> <span style=color:#61afef;font-weight:700>stk</span>(<span style=color:#98c379>&#34;Hello&#34;</span>);
</span></span></code></pre></div><p>此时我们可以看见对于<code>stk</code>变量，其模版参数类型被推导为<code>const char *</code>(和<code>char const *</code>等价，都属于顶层<code>const</code>)。也可以看出这个构造函数匹配了<code>Stack(T elem)</code>，但是当我们看<code>stk_initList</code>时，我们却会发现不同的地方，虽然模版参数都被推导为了<code>const char *</code>，但是这里实际上调用了包含<code>initializer_list</code>的构造函数。
可是，如果我们需要更方便得去处理字符串，我们会希望虽然是通过<code>"Hello"</code>这样的字面量进行构造，但是其模版类型是<code>std::string</code>。那么我们可以通过推断指引进行解决。</p><h2 id=推断指引>推断指引
<a class=header-anchor href=#%e6%8e%a8%e6%96%ad%e6%8c%87%e5%bc%95></a></h2><p>推断指引在我的理解上，就是显式地指定某种类型的构造函数应该按照另一个指定的模版参数类型进行。这么说可能并不直观，我们看以下代码。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#e06c75>Stack</span>(<span style=color:#c678dd>const</span> <span style=color:#e5c07b>char</span><span style=color:#56b6c2>*</span>) <span style=color:#56b6c2>-&gt;</span> <span style=color:#e06c75>Stack</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>string</span><span style=color:#56b6c2>&gt;</span>;
</span></span></code></pre></div><p>我们该如何理解呢？我是这么理解的，<code>Stack(const char*)</code>代表了一个以<code>const char *</code>为参数类型的构造函数，当发生类型推导为<code>const char *</code>时，请将这样的类型推导为<code>std::string</code>进行实例化。此时我们再看上面的<code>Stack stk("Hello")</code>就会发现它的模板参数类型已经是<code>std::string</code>了。而<code>stk_initList</code>的却依然是<code>const char *</code>，这里实际上是由于它匹配的构造函数是<code>initializer_list</code>的构造函数，而并没有为该构造函数进行指引 ，通过添加下述语句，就可以保证此时也构造一个<code>std::string</code>模版类型的<code>Stack</code>了。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#e06c75>Stack</span>(<span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>initializer_list</span><span style=color:#56b6c2>&lt;</span><span style=color:#c678dd>const</span> <span style=color:#e5c07b>char</span><span style=color:#56b6c2>*&gt;</span>) <span style=color:#56b6c2>-&gt;</span> <span style=color:#e06c75>Stack</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>string</span><span style=color:#56b6c2>&gt;</span>;
</span></span></code></pre></div><p>需要指出的是，这个指引语句必须出现在和模版类的定义相同的作用域或命名空间内。😎</p><h2 id=模板部分特例化>模板部分特例化
<a class=header-anchor href=#%e6%a8%a1%e6%9d%bf%e9%83%a8%e5%88%86%e7%89%b9%e4%be%8b%e5%8c%96></a></h2><p>我们应该也接触过，比如说<code>Stack&lt;int>{......};</code>就是一种对于<code>int</code>类型的特例化，但是我们可能并未察觉，其实特例化还可以是模板，而且还可以在底层实现上与原来完全不一样。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#c678dd>template</span> <span style=color:#56b6c2>&lt;</span><span style=color:#c678dd>typename</span> <span style=color:#e06c75>T</span><span style=color:#56b6c2>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>Stack</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>T</span> <span style=color:#56b6c2>*&gt;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#c678dd>private</span><span style=color:#56b6c2>:</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>deque</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>T</span> <span style=color:#56b6c2>*&gt;</span> <span style=color:#e06c75>m_data</span>;
</span></span><span style=display:flex><span><span style=color:#c678dd>public</span><span style=color:#56b6c2>:</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>Stack</span>(<span style=color:#e06c75>T</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>elem</span>) { <span style=color:#e06c75>m_data</span>.<span style=color:#e06c75>push_back</span>(<span style=color:#e06c75>elem</span>); }
</span></span><span style=display:flex><span>    <span style=color:#e5c07b>void</span> <span style=color:#61afef;font-weight:700>print</span>() { <span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>println</span>(<span style=color:#98c379>&#34;Stack&lt;T*&gt;&#34;</span>); }
</span></span><span style=display:flex><span>}; <span style=color:#7f848e>// 一个专门处理指针的特例,可以连底层实现都完全不
</span></span></span></code></pre></div><p>这里我们特例化了一个专门处理指针类型的<code>Stack&lt;T*></code>，这个特例的底层不再使用<code>std::vector</code>实现，反而直接使用到<code>std::deque</code>实现，同时还定义了一个接受指针的构造函数。如果我们传入一个指针，那么会匹配这个特例化的类，当然，也有反例。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#e5c07b>int</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>p</span> <span style=color:#56b6c2>=</span> <span style=color:#c678dd>new</span> <span style=color:#e5c07b>int</span>[<span style=color:#d19a66>7</span>];
</span></span><span style=display:flex><span><span style=color:#e06c75>Stack</span> <span style=color:#61afef;font-weight:700>stk_ptr</span>(<span style=color:#e06c75>p</span>);
</span></span><span style=display:flex><span><span style=color:#c678dd>delete</span> [] <span style=color:#e06c75>p</span>;
</span></span></code></pre></div><p>在上面这个例子当中，我们可以发现<code>stk_ptr</code>具有方法<code>.print()</code>，但是当我们把<code>int</code>换成<code>char</code>之后，这个<code>stk_ptr</code>不再有<code>.print()</code>方法，反而被实例化为了<code>Stack&lt;std::string></code>类型，这里发生了推断指引，且被构造为了原来的<code>Stack&lt;T></code>这样的类型。其实也很好理解，毕竟发生推断指引后，模版参数类型就不再是指针了，自然不会匹配特例化的指针类型<code>Stack</code>。</p><h2 id=聚合类的模版>聚合类的模版
<a class=header-anchor href=#%e8%81%9a%e5%90%88%e7%b1%bb%e7%9a%84%e6%a8%a1%e7%89%88></a></h2><p>聚合类其实就是一堆元素绑在一个结构体里面，没有显示定义构造函数，也没有继承来的构造函数，不指定<code>private</code>等标识，可以参考<code>C++ primer</code>，定义可能并不统一。以下就是一个聚合类。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#c678dd>template</span> <span style=color:#56b6c2>&lt;</span><span style=color:#c678dd>typename</span> <span style=color:#e06c75>T</span><span style=color:#56b6c2>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>struct</span> <span style=color:#e5c07b>ValueWithComment</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#e06c75>T</span> <span style=color:#e06c75>value</span>;
</span></span><span style=display:flex><span>    <span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>string</span> <span style=color:#e06c75>comment</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这个类有一个模版参数，我们当然也可以为其实例化赋值，然而这里的第二个实例化却无法编译过。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#e06c75>ValueWithComment</span> <span style=color:#e06c75>valWizComet</span>{<span style=color:#d19a66>10</span>, <span style=color:#98c379>&#34;hlo&#34;</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e06c75>ValueWithComment</span> <span style=color:#e06c75>valWizComet1</span> <span style=color:#56b6c2>=</span> {<span style=color:#d19a66>10</span>, <span style=color:#98c379>&#34;hlo&#34;</span>};
</span></span></code></pre></div><p>因为聚合类的原因，并没有定义拷贝构造函数，编译器无法推导出其类型，甚至直接使用<code>{.value=10 , .comment="hlo"}</code>也不行。此时就需要进行推断指引。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#e06c75>ValueWithComment</span>(<span style=color:#e5c07b>int</span>, <span style=color:#c678dd>const</span> <span style=color:#e5c07b>char</span><span style=color:#56b6c2>*</span>) <span style=color:#56b6c2>-&gt;</span> <span style=color:#e06c75>ValueWithComment</span><span style=color:#56b6c2>&lt;</span><span style=color:#e5c07b>int</span><span style=color:#56b6c2>&gt;</span>;
</span></span></code></pre></div><p>当然，也可以把<code>int</code>也换成模版，例如</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#c678dd>template</span> <span style=color:#56b6c2>&lt;</span><span style=color:#c678dd>typename</span> <span style=color:#e06c75>T</span><span style=color:#56b6c2>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>ValueWithComment</span>(<span style=color:#e06c75>T</span>, <span style=color:#c678dd>const</span> <span style=color:#e5c07b>char</span><span style=color:#56b6c2>*</span>) <span style=color:#56b6c2>-&gt;</span> <span style=color:#e06c75>ValueWithComment</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>T</span><span style=color:#56b6c2>&gt;</span>;
</span></span></code></pre></div><p>此时即没有失去泛化能力，也能保证直接构造了。</p><h2 id=为模版类进行函数重载>为模版类进行函数重载
<a class=header-anchor href=#%e4%b8%ba%e6%a8%a1%e7%89%88%e7%b1%bb%e8%bf%9b%e8%a1%8c%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd></a></h2><p>这里主要以<code>std::cout</code>进行重载。当希望能直接用<code>std::cout</code>打印出自定义类对象时，就需要重载<code>operator&lt;&lt;</code>。此时就需要用到友元。我们也可以直接定义一个<code>print</code>函数把<code>std::ostream</code>作为参数进行传入，但是还是让我们谈谈友元的方法。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#c678dd>template</span> <span style=color:#56b6c2>&lt;</span><span style=color:#c678dd>typename</span> <span style=color:#e06c75>T</span><span style=color:#56b6c2>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>Stack</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>template</span> <span style=color:#56b6c2>&lt;</span><span style=color:#c678dd>typename</span> <span style=color:#e06c75>T</span><span style=color:#56b6c2>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>ostream</span> <span style=color:#56b6c2>&amp;</span><span style=color:#c678dd>operator</span><span style=color:#56b6c2>&lt;&lt;</span>(<span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>ostream</span> <span style=color:#56b6c2>&amp;</span>, <span style=color:#e06c75>Stack</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>T</span><span style=color:#56b6c2>&gt;</span> <span style=color:#c678dd>const</span> <span style=color:#56b6c2>&amp;</span>);
</span></span></code></pre></div><p>为保证友元函数声明时正常，需要预先声明类模版<code>Stack</code>，然后继续声明一个模版<code>operator&lt;&lt;</code>，这时在<code>Stack&lt;T></code>类的定义里面就可以加上友元声明。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#c678dd>template</span> <span style=color:#56b6c2>&lt;</span><span style=color:#c678dd>typename</span> <span style=color:#e06c75>T</span><span style=color:#56b6c2>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>class</span> <span style=color:#e5c07b>Stack</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#c678dd>friend</span> <span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>ostream</span> <span style=color:#56b6c2>&amp;</span><span style=color:#c678dd>operator</span><span style=color:#56b6c2>&lt;&lt;</span> <span style=color:#56b6c2>&lt;&gt;</span>(<span style=color:#e06c75>std</span><span style=color:#56b6c2>::</span><span style=color:#e06c75>ostream</span> <span style=color:#56b6c2>&amp;</span>, <span style=color:#e06c75>Stack</span><span style=color:#56b6c2>&lt;</span><span style=color:#e06c75>T</span><span style=color:#56b6c2>&gt;</span> <span style=color:#c678dd>const</span> <span style=color:#56b6c2>&amp;</span>);
</span></span><span style=display:flex><span>	<span style=color:#7f848e>// or
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>	<span style=color:#7f848e>//friend std::ostream &amp;operator&lt;&lt; &lt;T&gt;(std::ostream &amp;, Stack&lt;T&gt; const &amp;);
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>};
</span></span></code></pre></div><p>然而我一开始对这里<code>operator&lt;&lt;</code>之后出现的<code>&lt;></code>感到困惑，为什么要加这个？就像我之前提到的，我们重载的函数被声明为了模版，而友元的声明则是对该模版进行实例化，我又疑惑了，为什么要实例化？其实对于<code>Stack</code>这样一个类模版，当我们使用它时，例如<code>Stack&lt;int> stk</code>，都有实例化一份代码，而不同的<code>operator&lt;&lt;</code>实际上针对的就是这些实例化的<code>Stack</code>进行，比如说<code>Stack&lt;int></code>，我们要打印这样的类型，那么自然<code>operator&lt;&lt;</code>也是<code>Stack&lt;int></code>类型的友元，那么显然是已经实例化的<code>operator&lt;&lt; &lt;int></code>。所以这里需要实例化。
那我又疑惑了，不是在参数列表里面已经有了<code>Stack&lt;T></code>吗，为什么还要在函数加一个？其实是要求调用模版函数，因为一开始的声明本身就是模版函数，此时自然是调用该模版函数的实例化版本。这点其实可以在<code>operator&lt;&lt; &lt;T></code>的友元声明中看出。</p><h2 id=总结>总结
<a class=header-anchor href=#%e6%80%bb%e7%bb%93></a></h2><p>这章内容其实不多，还未真正触及到模版元编程的 Core，但是也有很多新概念需要注意。同时我学下来感觉，嗯 · · · · · · 这个不显式指定模版类型而让编译器去推导有时候真的很麻烦，例如聚合类，总有种重复造轮子的感受。而且当我们需要针对不同的类型进行特化处理时，也要格外小心模版被推导为了其他的特化类型，而不是我们想要的那个，这也挺难留意的。
所以总结就是，尽量少让编译器自己推导，特别是你不确定编译器会推导成什么的时候😇 。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/c++>C++</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
C++类模版</li><li class=post-copyright-author><strong>原文作者： </strong>Laplace</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=http://localhost:1313/post/cpp-class-template/ title=C++类模版>http://localhost:1313/post/cpp-class-template/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=https://github.com//laplace825><span class=icon><i class="fab fa-github"></i>
</span><span class=label>Github</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/cpp-no-type-param-template/ rel=next title=C++非类型模版参数><i class="fa fa-chevron-left"></i> C++非类型模版参数</a></div><div class="post-nav-prev post-nav-item"><a href=/post/useneovidewithlunarvimwindows/ rel=prev title=Windows下使用neovide+lunarvim>Windows下使用neovide+lunarvim
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2023 - 2024
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>Laplace</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.127.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#22ffff","enable":true,"save":"auto"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"http://localhost:1313/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lawidget":{"id":"3HTyuds4Bm5FaDq4","js":"https://v6-widget.51.la/v6/laId/quote.js?theme=0\u0026col=true\u0026f=12\u0026display=0,0,0,1,0,1,1,1"},"lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"zoomInLeft","postblock":"zoomInLeft","postbody":"zoomIn","postheader":"bounceIn","sidebar":"zoomInLeft"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":false,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.5.3","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.js defer></script><script type=text/javascript src=/js/math.js defer></script></body></html>